# 小系統到大系統

根據莫爾定律，電腦的計算能力用一個很誇張的速度在增長，而且目前看起來並不會減慢。一般來說，高階系統，伺服器等電腦都不是只有一個CPU的系統。對於如何達成各個CPU的協作有很多種方式。

## 對稱多處理(Symmetric Multi-Processing)

對稱多處理系統(Symmetric Multi-Processing, SMP) 是一個系統裡面包含多個CPU的一個常見的配置。`symmetric` 這個字代表所有的CPU都是相同的(同樣的架構，同樣的時鐘速度)。在SMP系統中，多個處理器會共享其他人的資源(resources)，例如記憶體、硬碟空間之類的。

## 快取一致性(Cache Coherency)

大多數的情況下，系統中的 CPU獨立運作，每個人都有自己的一組暫存器、program counter等。儘管他們分別獨立的運行，有一個重要的部分需要嚴格的同步(synchronisation)。

這個東西就是 CPU 快取，怕你忘記提醒一下，快取就是一個小的記憶體位置，可以快速的存取主記憶裡面的資訊。如果一個CPU對主記憶體中的資料進行修改，然後其他的CPU還在讀自己手上本來有的快取資訊，這樣系統就不處於同步的狀態。順帶一提，這種問題只有在寫入的時候才會發生，因為如果只是讀取的話，每個CPU讀取的資料都會相同。

為了要協調所有處理器都處於快取一致性的狀態，SMP系統會使用窺探(snooping)，窺探就是處理器會去監聽所有連接到匯流排的處理器，有沒有發生快取改變的事件，如果有的話就會作相對應的快取更新。

其中一個快取一致性的協定(Protocol)是MOESI協定，這幾個英文字分別代表修改（Modified），所有權（Owner），獨佔（Exclusive），共享（Shared），無效（Invalid）。這裡每一個英文字都是代表快取行(cache line) 上處理器的狀態。當然，還有協定，但是他們都有相似的概念，下面我們會仔細觀察 MOESI的協定，讓你有基本的認識。

當處理器需要從主記憶體讀取快取的時候，處理器會先去窺探(snooping)系統中所有的處理器，看看其他處理器有沒有對於這塊記憶體的訊息(例如，這段記憶體已經被其他處理器快取了)。如果目前並沒有任何處理器有這段記憶體的資料，那使處理器就會快取這段記憶體，然後把這段標為獨佔(E)，當寫入快取這件事情發生的時候，就把狀態標記程修改(M)，下面開始就有趣了，有一些快取會馬上寫回主記憶體(這個就被稱為 write-through ，因為寫入的動作直接寫到主記憶體)，有一些快取會只先寫到快取上，除非快取被寫滿了或是逐出(evicted)才會寫入主記憶體。

另外一種情況就是當處理器窺探其他處理器的時候，發現有人標記這段記憶體為修改(M)，這個時候就把資料複製一分到自己的快取，並且標記共享(Shared)，他會傳訊息給其他處理器，告訴大家剛剛那個M改成所有者(O)。想像中，現在有第三個處理器想要使用這塊記憶體的資料的時候，他會看到一個S跟一個O。這個時候他會去O那邊複製一份資料到自己的快取。如果現在其他處理器都只是要讀取，快取行(cache line)就會維持共享(S)的狀態。但是，當其中一個處理器想要更新那段資料的時候，他需要傳送無效(invalidate)訊息給其他的處理器。有快取這段資料的處理器就要把自己的快取標記成無效(I)，代表現在這個快取上面的資料已經不是正確的資料了。當這段無效訊息除給其他處理器之後，自己的快取行標記成修改(M)，其他處理器標記程無效(I)。順帶一提，如果這個快取行是獨佔的(E)，處理器就會知道沒有其他的處理器會用到這段資料，就可以避免傳送無效訊息給其他處理器。

從現在開始，整個邏輯就開始了。所以不管是哪個處理器擁有被標記成修改(M)的快取，那個處理器就有責任在逐出(evicted)的時候，把這段資料寫回主記憶體。透過思考這個協定，你就會知道，這個協定是要確保各個處理器的快取行的資料是一致的。

當系統處理器的數量增加的時候會產生一些問題。當處理器數量不多的時候，檢查其他的處理器是否擁有這個快取行的資料，或是檢查這個快取行是不是有效的資料(這個就是一個snoop的意思)所花的時間不多，但如果很多個處理器的時候，匯流排的訊息會太忙碌。這也就是為什麼SMP系統通常最多只有八個處理器的原因。

而且將所有的處理器都放在同一個匯流排上有物理上的限制，一般物理上的電線只能用特定的距離去排列，並且有長度的限制。對於一秒鐘幾千兆赫茲(GHz)運算的處理器來說，就算是用光速傳遞資訊，也需要考慮資料在這些導線裡面傳輸的時間。

請注意，通常系統軟體不會參與這個過程，雖然說寫程式的人應該知道硬體底層做了什麼事情，才可以知道怎麼樣最佳化自己的程式效率。

``
