# 作業系統架構

作業系統的架構大概長的像下面張圖這樣

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption><p>這是一個作業系統的概念圖，從最上面開始看是使用者的區域(User space)，會有很多任務，這些任務的先後順序跟資源分配都是由系統核心（kernel）完成。核心會直接或透過驅動(Driver)跟硬體溝通，完成使用者想要達成的任務。可以把核心想成一種大型的硬體API</p></figcaption></figure>

## 作業系統核心 (Kernel)

所謂的作業系統核心，以下簡稱核心，就是指作業系統。就跟上面那張圖顯示的一樣，核心會跟直接或是透過驅動跟硬體溝通。

核心會抽象化硬體，讓程式可以運行。驅動(Driver)抽象化硬體，讓核心可以運行。舉例來說，我們有很多不同類型的顯示卡，每張顯示卡都有自己硬體上的特色。只要核心提供一個API介面，知道硬體規格的人就可以寫驅動程式來實現這個API，讓核心可以藉由這個API存取各種不同的硬體。

核心通常被稱為特權(privileged)。後面會學到，硬體在多工處理跟系統安全性上，但是這些規則不適用於核心。我們知道核心需要處理當掉的程式(剛剛有提到作業系統的功能就是分配多個任務的資源，但不會保證這個程式的運行狀態，也就是當掉是程式會發生的憾事，作業系統要處能處理)。但是如果作業系統當掉了，那整台電腦都會當掉。同樣的，如果使用者的行程 (process)可以把自己的安全級別提升到kernel等級的權限的話，那 這個程式就能控制整台電腦了。

{% hint style="info" %}
這段應該是在說核心有特權，安全性跟例外處理是跟一般process完全不同的。
{% endhint %}

## 單一核心(**Monolithic)?微核心(Microkernels)?**

這個是一個長久以來的爭執，到底是單一核心好，還是微核心好？

單一核心是最常見的，也是被Unix系列(例如Linux)採用的方法。在單一核心的架構下，核心的特權是很大的，包含硬體的驅動，檔案系統，權限管理，網路檔案系統( Network File System, NFS)等等的服務都算在核心的範圍。

單一核心的缺點就是，由於核心擁有特權，掌控整台電腦，核心的任何一個部份當機都會使的整個系統停擺，如果驅動程式有bug，他就能夠成功覆蓋系統中隨便一個位置的記憶體內容，導致系統當機。

所謂微核心的架構就是為了最小化這種可能性，希望核心做的事情越少越好。也就是說，大部分的系統都是執行非特權的程式，從而限制任意一個核心的部份都會造成整台電腦當機的可能性。例如，硬體驅動程式是一個獨立的行程(process），當這個行程發生錯誤的時候，除了他自己當初被分配的那塊記憶體空間以外，他不能覆蓋其他行程的記憶體位置。

那微核心聽起來厲害多了，那還有什麼好吵的？大家主要是在吵

1. 效能會下降，不同組件之間溝通需要時間成本。
2. 對於撰寫程式的人來說，這個架構比較複雜

因為微核心的功能元件化的因素，各個元件(components)需要互相傳遞訊訊息，所以會效能下降，對於程式設計師來說比較複雜。通常這種溝通叫做[行程間通訊](https://zh.wikipedia.org/zh-tw/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A) (inter-process communication, IPC)。各個模組通訊是用一種離散的方式傳遞。離散的意思是：訊息會先被封裝成一個單位，送給其他模組，然後其他元件需要解碼這段訊息，執行動作，最後再把訊息封裝成一個單位回傳給其他的元件。

這樣子的話，一個很簡單的指令會因為要呼叫外部的元件而產生很多步驟，很明顯的，一個通訊的請求很有可能發起更多的通訊請求，那速度就會降慢很多倍。早期微核心系統因爲訊息傳遞的效率不佳，傳遞資訊的概念對寫程式的人來說又有點難。只是更加多一些的系統安全性而犧牲效能讓微核心系統變得很不流行。

然後在單一核心的系統之中，元件之間的調用就像是一般的函式呼叫。就跟一般軟體的理解一樣。

至於那一個才是比較好的架構，學術上跟非學術上有很多爭論，希望你學完了這些跟作業系統相關的課程之後，你會有你自己的看法。

### **核心模組 Modules**

Linux 核心實做了一個模組系統，也就是說，硬體驅動在需要的時候再動態的載入核心就可以了。這就代表，整個核心很大包的程式碼，其中涵蓋各式各樣不同的驅動程式，並不會全部都載入你的系統，只有你擁有這個硬體，才會載入這段驅動程式。這樣讓某些作業系統開發的人(如RedHat, Debian)可以將大多數的驅動程式包裝成一個個的模組，讓他們的程式可以適應很多不同的硬體。

但是，這些模組都是直接載入核心，也就是擁有跟核心一樣的特權。所以這種系統一樣被視為是單一核心。

{% hint style="info" %}
翻譯上 module 跟 component 都筆者都將其翻譯成模組，語意上沒有區分

[https://stackoverflow.com/questions/2702816/module-vs-component-design](https://stackoverflow.com/questions/2702816/module-vs-component-design)
{% endhint %}

## **虛擬化 (Virtualisation)**

另外一個跟核心相關的概念就是硬體的虛擬化。現代的電腦效能非常的好，所以通常為把物理上的一台電腦，拆分成很多虛擬的電腦，每一個虛擬電腦都互相不影響，可以獨立完成任務，但實際上都是同一台電腦。

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption><p>這張圖呈現了三種不一樣的虛擬化， 左上是（1）虛擬器監視器(<em>virtual machine monitor, VMM, hypervisor</em>)，右上是 (2) 折衷的VMM ，作業系統需要直接要求其所需的資源</p></figcaption></figure>

有很多種虛擬化的方法，最簡單的例子就是，虛擬器監視器(_virtual machine monitor, VMM, hypervisor_)，這個VMM會在直接運行在硬體上面，然後提供界面給客戶端的作業系統。客戶端的作業系統根本不知道有沒有VMM的存在，因為VMM長的就像一個硬體界面，他會攔截客戶端作業系統傳給硬體的訊息，然後動點手腳，或使只分配一部分的硬體資源給這個客戶端系統這樣。所以這種VMM 也被稱為(hypervisor, 來自於主管這個單字）

這種作法通常用於大型的電腦(那種有很多CPU跟記憶體的那種電腦)，這樣做可以實現分割(partitioning)，也就是把機台拆分成很多小的虛擬機，當需要比較多計算量的時候，VMM可以動態的分配更多資源給虛擬機。許多大型的IBM伺服器都擁有這種功能，這種功能其實很複雜(上百萬行程式碼)，提供大量的伺服器管理服務。

另外一種作法就是讓作業系統知道VMM的存在，從而透過VMM存取硬體資源。這種方法被稱為半虛擬化(_paravirtualisation)_，早期的 Xen 系統採用了這種策略作為折衷方案。希望這樣可以提供更好的效能，因為作業系統需要明確的要求VMM給予系統支援，而不是由 VMM自動態的解決分配資源的問題。

最後，還有一種情況是這樣：在現有的作業系統上面運行一個應用程式，這個應用程式就是一個虛擬化的作業系統(裡面包含CPU, 記憶體, 硬碟空間等)。應用程式透過底下的作業系統使用硬體的功能這個大概就是 VMWare 的工作原理。這種方法有很多成本(overheads)，因為這個應用程式需要模擬整個作業系統的運作，然後把應用程式的請求轉換成底層的硬體操作。但是，這個可以讓我們在同一台電腦上模擬各種不同的作業系統，因為我們可以動態的翻譯不同的處理器的CPU 指令。(這就跟 Rosetta 從powerPC處理器到 intel 處理器，到ARM處理器都能使用的感覺)

這些虛擬化的技術最重要的問題就是性能， 因為本來可以直接在硬體上操作多了一層抽象層

&#x20;Intel曾經討論過硬體支援虛擬化的功能， 而且已經實現在最新的處理器上。 怎麼做呢？當有應用程式要求一些作業系統共享的資源的時候會觸發一個特殊的異常(exception)， 這個異常會通知VMM ，讓 VMM 去處理資源分配的問題。

這樣就提供了很不錯的效能， 因為虛擬機不需要時時刻刻去檢查每一個操作是否安全， 虛擬機只需要等到處理器 觸發異常的時候再處理就可以了。



**虛擬化的小秘密**

這是另外一個題外話， 一個有關於虛擬機的安全性問題： 如果不是靜態的做分割（partitioning） 也就是說動態的做分割會有安全性問題。

在動態配置的虛擬系統會根據作業系統的需求去分配給作業系統。 也就是說：如果有一個人需要很多的CPU運算那另外一個人， 只是在等待硬碟回傳資料， 再這樣子的情況下第一個工作會分配比較多的CPU算力。

在這種情況下，事實上就可以讓兩個作業系統之間做一個交流，作者叫他 (_covert channel_) 作業系統去檢查他可以使用的資源的多寡就可以知道另外一個作業系統的狀態

雖說這個大家都覺得有點牽強，但這個機制違反了安全性的問題

### 使用者空間(Userspace)

我們把使用者的應用程式運行的地方叫做使用者空間， 使用者程式都執行在使用者空間，他們藉由系統呼叫(_system calls_) 跟核心溝通。

我們剛討論的一樣使用者空間沒有特權(_unprivileged_) ，他們沒有辦法使其他的程式崩潰





